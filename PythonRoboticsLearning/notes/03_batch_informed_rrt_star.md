# Batch Informed RRT* (BIT*) è·¯å¾„è§„åˆ’ç®—æ³•å­¦ä¹ ç¬”è®°

> **å­¦ä¹ æ—¥æœŸ**: 2026-01-13
> **ç®—æ³•ç±»åˆ«**: é‡‡æ ·è§„åˆ’ç®—æ³•
> **éš¾åº¦ç­‰çº§**: â­â­â­â­ (é«˜çº§)
> **æ–‡ä»¶è·¯å¾„**: `PathPlanning/BatchInformedRRTStar/batch_informed_rrt_star.py`
> **ä»£ç è¡Œæ•°**: 635 è¡Œ

---

## ğŸ“– ç®—æ³•æ¦‚è¿°

### æ ¸å¿ƒæ€æƒ³
Batch Informed Trees (BIT*) æ˜¯ä¸€ç§ç»“åˆäº†é‡‡æ ·æ–¹æ³•å’Œå¢é‡å›¾æœç´¢çš„è·¯å¾„è§„åˆ’ç®—æ³•ã€‚å®ƒé€šè¿‡æ‰¹å¤„ç†æœºåˆ¶å’Œå¯å‘å¼é‡‡æ ·ï¼Œå®ç°äº†æ¯” RRT* å’Œ Informed RRT* æ›´å¿«çš„æ”¶æ•›é€Ÿåº¦ã€‚

### ç®—æ³•æ¼”è¿›å†å²

```
RRT (1998)
  â†“ æ·»åŠ æˆæœ¬ä¼˜åŒ–å’Œé‡è¿
RRT* (2011) [æ¸è¿›æœ€ä¼˜]
  â†“ æ·»åŠ å¯å‘å¼é‡‡æ ·ç©ºé—´
Informed RRT* (2014) [æ¤­åœ†å½¢é‡‡æ ·]
  â†“ æ‰¹å¤„ç†å’Œå›¾æœç´¢ä¼˜åŒ–
Batch Informed RRT* (2014) [æ‰¹å¤„ç†å›¾æœç´¢]
```

### å…³é”®åˆ›æ–°ç‚¹

1. **æ‰¹å¤„ç†å¢é‡å›¾æœç´¢**: ç»“åˆ A* é£æ ¼çš„å›¾æœç´¢å’Œé‡‡æ ·æ–¹æ³•
2. **åŒé˜Ÿåˆ—ç³»ç»Ÿ**: vertex_queue æ§åˆ¶æ‰©å±•ï¼Œedge_queue æ§åˆ¶è¿æ¥
3. **æ¤­åœ†å½¢å¯å‘å¼é‡‡æ ·**: èšç„¦æœ€ä¼˜è·¯å¾„é™„è¿‘
4. **ä¿¡æ¯é‡ç”¨**: æ ‘ç»“æ„åœ¨è¿­ä»£é—´ä¿æŒå’Œä¼˜åŒ–

### è®ºæ–‡å‚è€ƒ
- Title: "Batch Informed Trees (BIT*): Informed asymptotically optimal anytime path planning"
- ArXiv: https://arxiv.org/abs/1405.5848

---

## ğŸ”¬ æ•°å­¦åŸç†è¯¦è§£

### 1. æ¤­åœ†å½¢é‡‡æ ·ç†è®º

#### æ¤­åœ†å®šä¹‰

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:186-199`

```python
# æ¤­åœ†å‚æ•°è®¡ç®—
cMin = math.hypot(start[0] - goal[0], start[1] - goal[1]) / 1.5
xCenter = np.array([[(start[0] + goal[0]) / 2.0],
                    [(start[1] + goal[1]) / 2.0], [0]])
```

**æ•°å­¦å…¬å¼**:

\[
\begin{aligned}
c_{min} &= \frac{\|x_{start} - x_{goal}\|_2}{1.5} \\
x_{center} &= \frac{x_{start} + x_{goal}}{2}
\end{aligned}
\]

**ä¸ºä»€ä¹ˆé™¤ä»¥ 1.5ï¼Ÿ**
- âš ï¸ ä»£ç ä¸­çš„å®ç°ç»†èŠ‚ï¼ˆéœ€è¦è¿›ä¸€æ­¥åˆ†æï¼‰
- å¯èƒ½æ˜¯ä¸ºäº†æä¾›åˆå§‹çš„æ¤­åœ†åŠå¾„ç¼“å†²

#### åæ ‡å˜æ¢çŸ©é˜µ

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:190-199`

```python
# æ„é€ æ—‹è½¬çŸ©é˜µ
a1 = np.array([[(goal[0] - start[0]) / cMin],
               [(goal[1] - start[1]) / cMin], [0]])
M = np.dot(a1, id1_t)
U, S, Vh = np.linalg.svd(M, True, True)
C = np.dot(np.dot(U, np.diag([1.0, 1.0, np.linalg.det(U) * np.linalg.det(np.transpose(Vh))])),
           Vh)
```

**æ•°å­¦æ¨å¯¼**:

1. **æ„é€ æ–¹å‘å‘é‡** a1: ä»èµ·ç‚¹æŒ‡å‘ç»ˆç‚¹
2. **SVD åˆ†è§£**: è®¡ç®—æ—‹è½¬çŸ©é˜µ C
   \[
   M = a_1 \cdot I_1^T
   \]
   \[
   U, S, V^T = \text{SVD}(M)
   \]
   \[
   C = U \cdot \text{diag}(1, 1, \det(U)\det(V^T)) \cdot V^T
   \]

3. **å˜æ¢å…¬å¼**:
   \[
   x_{sample} = C \cdot L \cdot x_{ball} + x_{center}
   \]
   å…¶ä¸­:
   \[
   L = \text{diag}\left(\frac{c_{best}}{2}, \frac{\sqrt{c_{best}^2 - c_{min}^2}}{2}, \dots\right)
   \]

### 2. æ‰¹å¤„ç†å¢é‡å›¾æœç´¢

#### ä»£ä»·å‡½æ•°å®šä¹‰

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:173-180, 382-387`

```python
# g_score: ä»èµ·ç‚¹åˆ°é¡¶ç‚¹çš„å®é™…ä»£ä»·
self.g_scores[node_id] = actual_cost

# f_score: g_score + å¯å‘å¼ä»£ä»·
self.f_scores[node_id] = g_score + heuristic_cost

# å¯å‘å¼å‡½æ•°ï¼ˆæ¬§å‡ é‡Œå¾—è·ç¦»ï¼‰
def compute_heuristic_cost(self, start_id, goal_id):
    start = np.array(self.tree.node_id_to_real_world_coord(start_id))
    goal = np.array(self.tree.node_id_to_real_world_coord(goal_id))
    return np.linalg.norm(start - goal, 2)
```

**æ•°å­¦å…¬å¼**:

\[
\begin{aligned}
g(v) &= \text{actual cost from start to vertex } v \\
h(v) &= \|x_v - x_{goal}\|_2 \quad \text{(Euclidean heuristic)} \\
f(v) &= g(v) + h(v)
\end{aligned}
\]

#### åŒé˜Ÿåˆ—ç³»ç»Ÿ

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:150-151, 246-247`

```python
self.vertex_queue = []  # å¾…æ‰©å±•çš„é¡¶ç‚¹
self.edge_queue = []    # å€™é€‰è¾¹é˜Ÿåˆ—

# é˜Ÿåˆ—å€¼æ¯”è¾ƒ
while best_vertex_queue_value() <= best_edge_queue_value():
    expand_vertex(best_vertex)
```

**é˜Ÿåˆ—å€¼è®¡ç®—**:

- **é¡¶ç‚¹é˜Ÿåˆ—å€¼**:
  \[
  \text{vertex\_value} = \min_{v \in \text{vertex\_queue}} (g(v) + h(v))
  \]

- **è¾¹é˜Ÿåˆ—å€¼**:
  \[
  \text{edge\_value} = \min_{(v, x) \in \text{edge\_queue}} (g(v) + c(v, x) + h(x))
  \]

**å†³ç­–é€»è¾‘**:
- å¦‚æœ vertex_value â‰¤ edge_value: æ‰©å±•é¡¶ç‚¹ï¼ˆç”Ÿæˆæ›´å¤šå€™é€‰è¾¹ï¼‰
- å¦åˆ™: è¿æ¥æœ€ä½³è¾¹åˆ°æ ‘

### 3. æ”¶æ•›æ€§åˆ†æ

**ç†è®ºæ”¶æ•›ç‡**:

| ç®—æ³• | æ”¶æ•›ç‡ | è¯´æ˜ |
|------|--------|------|
| RRT | æ…¢ | æ— æœ€ä¼˜æ€§ä¿è¯ |
| RRT* | O(1/log n) | æ¸è¿›æœ€ä¼˜ |
| Informed RRT* | O(1/log n) | æ¤­åœ†é‡‡æ ·åŠ é€Ÿ |
| BIT* | O(1/n) | æœ€å¿«æ”¶æ•› |

---

## ğŸ—ï¸ ä»£ç æ¶æ„åˆ†æ

### 1. RTree ç±» - ç½‘æ ¼åŒ–æ ‘ç»“æ„

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:26-133`

**æ ¸å¿ƒèŒè´£**: æä¾›ç©ºé—´ç´¢å¼•åŠ é€Ÿçš„æ ‘æ•°æ®ç»“æ„

#### ä¸‰å±‚åæ ‡è½¬æ¢ç³»ç»Ÿ

```python
Real World (è¿ç»­) â†’ Grid Space (ç¦»æ•£) â†’ Node ID (å”¯ä¸€æ•´æ•°)
(1.23, 4.56)    â†’ (123, 456)        â†’ 123456
```

**å…³é”®æ–¹æ³•**:

| æ–¹æ³• | è¡Œå· | ä½œç”¨ |
|------|------|------|
| `real_coords_to_grid_coord()` | 75 | å®é™…åæ ‡ â†’ ç½‘æ ¼åæ ‡ |
| `grid_coordinate_to_node_id()` | 86 | ç½‘æ ¼åæ ‡ â†’ èŠ‚ç‚¹ ID |
| `real_world_to_node_id()` | 97 | å®é™…åæ ‡ â†’ èŠ‚ç‚¹ IDï¼ˆç»„åˆï¼‰ |
| `node_id_to_real_world_coord()` | 128 | èŠ‚ç‚¹ ID â†’ å®é™…åæ ‡ï¼ˆé€†å˜æ¢ï¼‰ |

**ç½‘æ ¼åŒ–ç¤ºä¾‹**:

```python
# åˆå§‹åŒ–å‚æ•°
lowerLimit = [0, 0]
upperLimit = [10, 10]
resolution = 0.01

# åæ ‡è½¬æ¢
real_coord = (1.23, 4.56)
grid_coord = (123, 456)  # (1.23/0.01, 4.56/0.01)
node_id = 123456         # å”¯ä¸€æ ‡è¯†ç¬¦
```

**ä¸ºä»€ä¹ˆéœ€è¦ç½‘æ ¼åŒ–ï¼Ÿ**
- âœ… ç©ºé—´ç´¢å¼•åŠ é€Ÿï¼ˆå¿«é€ŸæŸ¥æ‰¾é‚»è¿‘ç‚¹ï¼‰
- âœ… ç¦»æ•£åŒ–ä¾¿äºç®¡ç†
- âœ… Node ID ä½œä¸ºå­—å…¸é”®å€¼

### 2. BITStar ç±» - ä¸»ç®—æ³•å®ç°

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:135-609`

#### æ ¸å¿ƒæ•°æ®ç»“æ„

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:150-160`

```python
self.vertex_queue = []      # é¡¶ç‚¹é˜Ÿåˆ—ï¼ˆå¾…æ‰©å±•ï¼‰
self.edge_queue = []        # è¾¹é˜Ÿåˆ—ï¼ˆå€™é€‰è¿æ¥ï¼‰
self.samples = dict()       # é‡‡æ ·ç‚¹é›†åˆ
self.g_scores = dict()      # å®é™…ä»£ä»· g(v)
self.f_scores = dict()      # ä¼°è®¡ä»£ä»· f(v) = g(v) + h(v)
self.nodes = dict()         # çˆ¶å­å…³ç³»ï¼ˆè·¯å¾„å›æº¯ï¼‰
self.r = float('inf')       # æœç´¢åŠå¾„ï¼ˆåˆå§‹åŒ–ï¼‰
self.eta = 2.0              # å¯è°ƒå‚æ•°
self.old_vertices = []      # å·²å¤„ç†çš„é¡¶ç‚¹
```

#### å…³é”®æ–¹æ³•æ˜ å°„

| æ–¹æ³• | è¡Œå· | èŒè´£ | ä¼˜å…ˆçº§ |
|------|------|------|--------|
| `setup_planning()` | 167 | åˆå§‹åŒ–æ¤­åœ†å‚æ•°å’Œé‡‡æ · | â­â­â­â­â­ |
| `plan()` | 233 | ä¸»è§„åˆ’å¾ªç¯ | â­â­â­â­â­ |
| `setup_sample()` | 206 | æ‰¹å¤„ç†é‡‡æ · | â­â­â­â­ |
| `expand_vertex()` | 473 | æ‰©å±•é¡¶ç‚¹ç”Ÿæˆå€™é€‰è¾¹ | â­â­â­ |
| `update_graph()` | 521 | A* é£æ ¼å›¾æ›´æ–° | â­â­â­â­â­ |
| `informed_sample()` | 397 | æ¤­åœ†é‡‡æ · | â­â­â­â­â­ |
| `sample_unit_ball()` | 419 | å•ä½çƒé‡‡æ · | â­â­â­â­ |
| `connect()` | 356 | ç¢°æ’æ£€æµ‹è¿æ¥ | â­â­â­ |
| `find_final_path()` | 330 | è·¯å¾„å›æº¯ | â­â­ |

---

## ğŸ”„ ç®—æ³•æµç¨‹è¯¦è§£

### 1. åˆå§‹åŒ–é˜¶æ®µ (setup_planning)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:167-204`

**æ­¥éª¤åˆ†è§£**:

```python
# æ­¥éª¤ 1: è®¡ç®—èµ·ç‚¹å’Œç»ˆç‚¹çš„ node_id
self.startId = self.tree.real_world_to_node_id(self.start)
self.goalId = self.tree.real_world_to_node_id(self.goal)

# æ­¥éª¤ 2: åˆå§‹åŒ–ä»£ä»·å‡½æ•°
self.g_scores[self.goalId] = float('inf')  # ç»ˆç‚¹åˆå§‹ä»£ä»·ä¸ºæ— ç©·
self.f_scores[self.startId] = 0 + heuristic(start, goal)

# æ­¥éª¤ 3: è®¡ç®—æ¤­åœ†å‚æ•°
cMin = distance(start, goal) / 1.5
xCenter = (start + goal) / 2
# SVD åˆ†è§£è®¡ç®—æ—‹è½¬çŸ©é˜µ C
U, S, Vh = np.linalg.svd(M)
C = U @ diag([1, 1, det(U)*det(V^T)]) @ Vh

# æ­¥éª¤ 4: åˆå§‹é‡‡æ ·
self.samples.update(self.informed_sample(200, cBest, cMin, xCenter, C))
```

**æµç¨‹å›¾**:

```
å¼€å§‹
  â†“
è®¡ç®— startId, goalId
  â†“
åˆå§‹åŒ– g_scores, f_scores
  â†“
è®¡ç®—æ¤­åœ†å‚æ•° (cMin, xCenter, C)
  â†“
åˆå§‹é‡‡æ · (200 ä¸ªç‚¹)
  â†“
è¿”å›å‚æ•° â†’ ä¸»å¾ªç¯
```

### 2. æ‰¹å¤„ç†é‡‡æ ·å¾ªç¯ (setup_sample)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:206-231`

**è§¦å‘æ¡ä»¶**:

```python
if len(self.vertex_queue) == 0 and len(self.edge_queue) == 0:
    # å¼€å§‹æ–°çš„æ‰¹å¤„ç†
```

**é‡‡æ ·ç­–ç•¥**:

```python
if iterations != 0:
    if foundGoal:
        m = 200  # æ›´å¤šé‡‡æ ·ï¼Œæ¤­åœ†ç©ºé—´
        self.samples = dict()  # é‡ç½®é‡‡æ ·
    else:
        m = 100  # è¾ƒå°‘é‡‡æ ·ï¼Œå…¨ç©ºé—´

    cBest = self.g_scores[self.goalId]
    self.samples.update(self.informed_sample(m, cBest, cMin, xCenter, C))
```

**é‡‡æ ·æ•°é‡å¯¹æ¯”**:

| è¿­ä»£ | æ˜¯å¦æ‰¾åˆ°ç›®æ ‡ | é‡‡æ ·æ•° | é‡‡æ ·ç©ºé—´ |
|------|-------------|--------|----------|
| 0 | - | 200 | æ¤­åœ† |
| 1+ | å¦ | 100 | å…¨ç©ºé—´ |
| 1+ | æ˜¯ | 200 | æ¤­åœ† |

### 3. ä¸»è§„åˆ’å¾ªç¯ (plan)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:233-328`

**å®Œæ•´æµç¨‹**:

```python
while iterations < maxIter:
    # 1. æ‰¹å¤„ç†é‡‡æ ·
    cBest = self.setup_sample(iterations, foundGoal, cMin, xCenter, C, cBest)

    # 2. æ‰©å±•é¡¶ç‚¹ç›´åˆ°è¾¹æ›´ä¼˜
    while best_vertex_value <= best_edge_value:
        self.expand_vertex(best_vertex)

    # 3. é€‰æ‹©æœ€ä½³è¾¹
    bestEdge = self.best_in_edge_queue()

    # 4. æ£€æŸ¥è¾¹æ˜¯å¦æ”¹è¿›è§£ï¼ˆä¸‰ä¸ªæ¡ä»¶ï¼‰
    f1 = estimatedCostOfVertex < g_scores[goalId]
    f2 = estimatedCostOfEdge < g_scores[goalId]
    f3 = actualCostOfEdge < g_scores[goalId]

    if f1 and f2 and f3:
        # 5. è¿æ¥è¾¹åˆ°æ ‘
        path = self.connect(firstCoord, secondCoord)
        self.tree.add_edge(bestEdge[0], bestEdge[1])

        # 6. æ›´æ–°å›¾ï¼ˆA* é£æ ¼ï¼‰
        self.update_graph()
    else:
        # æ¸…ç©ºé˜Ÿåˆ—ï¼Œé‡æ–°å¼€å§‹
        self.edge_queue = []
        self.vertex_queue = []

    iterations += 1
```

**æµç¨‹å›¾**:

```
å¼€å§‹è¿­ä»£
  â†“
æ‰¹å¤„ç†é‡‡æ · (setup_sample)
  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ vertex_queue æœ‰å€¼ï¼Ÿ  â”‚
â”‚      â†“ Yes          â”‚
â”‚ æ‰©å±•é¡¶ç‚¹             â”‚
â”‚ ç”Ÿæˆå€™é€‰è¾¹åˆ° edge_queueâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  â†“ vertex_value > edge_value
é€‰æ‹©æœ€ä½³è¾¹ bestEdge
  â†“
æ£€æŸ¥ä¸‰ä¸ªæ¡ä»¶ (f1 && f2 && f3)
  â†“ Yes
è¿æ¥è¾¹ (ç¢°æ’æ£€æµ‹)
  â†“
æ›´æ–°å›¾ (update_graph)
  â†“
è¿­ä»£è®¡æ•°++
  â†“
è¿”å›æœ€ç»ˆè·¯å¾„
```

### 4. é¡¶ç‚¹æ‰©å±• (expand_vertex)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:473-498`

**æ‰©å±•é€»è¾‘**:

```python
def expand_vertex(self, vid):
    # 1. ä»é˜Ÿåˆ—ç§»é™¤é¡¶ç‚¹
    self.vertex_queue.remove(vid)

    # 2. è·å–å½“å‰é¡¶ç‚¹åæ ‡
    currCoord = self.tree.node_id_to_real_world_coord(vid)

    # 3. æ‰¾åˆ°åŠå¾„ r å†…çš„æ‰€æœ‰é‡‡æ ·ç‚¹
    neighbors = []
    for sid, s_coord in self.samples.items():
        if np.linalg.norm(s_coord - currCoord, 2) <= self.r:
            neighbors.append((sid, s_coord))

    # 4. å¯¹æ¯ä¸ªé‚»å±…ï¼Œåˆ›å»ºå€™é€‰è¾¹
    for neighbor in neighbors:
        sid = neighbor[0]
        estimated_f = g(start, vid) + h(vid, sid) + distance(vid, sid)
        if estimated_f < g_scores[goalId]:
            self.edge_queue.append((vid, sid))

    # 5. å°†é¡¶ç‚¹æœ¬èº«ä¹ŸåŠ å…¥è¾¹é˜Ÿåˆ—
    self.add_vertex_to_edge_queue(vid, currCoord)
```

**å…³é”®å‚æ•°**:
- æœç´¢åŠå¾„ `r = 2.0` (ç¬¬ 211 è¡Œ)
- é‚»å±…åˆ¤æ–­: `||s_coord - currCoord||â‚‚ â‰¤ r`

### 5. å›¾æ›´æ–° (update_graph)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:521-563`

**ç®—æ³•é£æ ¼**: A* çš„å¢é‡æ›´æ–°

```python
def update_graph(self):
    closedSet = []
    openSet = [self.startId]

    while len(openSet) != 0:
        # 1. é€‰æ‹© f_score æœ€å°çš„èŠ‚ç‚¹
        currId = min(openSet, key=lambda x: self.f_scores[x])
        openSet.remove(currId)

        # 2. æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç›®æ ‡
        if currId == self.goalId:
            break

        # 3. æ‰©å±•é‚»å±…
        successors = self.tree.vertices[currId]
        for successor in successors:
            if successor in closedSet:
                continue

            # 4. è®¡ç®— tentative g_score
            g_score = self.g_scores[currId] + distance(currId, successor)

            # 5. æ›´æ–°ä»£ä»·
            if g_score < self.g_scores[successor]:
                self.g_scores[successor] = g_score
                self.f_scores[successor] = g_score + heuristic(successor, goalId)
                self.nodes[successor] = currId  # è®°å½•çˆ¶èŠ‚ç‚¹
```

**ä¸ A* çš„å¯¹æ¯”**:

| ç‰¹æ€§ | A* | BIT* |
|------|-----|------|
| æœç´¢ç©ºé—´ | æ•´ä¸ªç½‘æ ¼ | ç°æœ‰æ ‘ + æ–°è¾¹ |
| é¡¶ç‚¹æ¥æº | æ‰€æœ‰ç½‘æ ¼ç‚¹ | æ ‘ä¸­é¡¶ç‚¹ |
| æ›´æ–°é¢‘ç‡ | æ¯æ¬¡è¿­ä»£ | æ·»åŠ è¾¹å |
| ç»ˆæ­¢æ¡ä»¶ | åˆ°è¾¾ç›®æ ‡ | è¾¹é˜Ÿåˆ—ç©º |

---

## ğŸ“Š RRT ç³»åˆ—å¯¹æ¯”åˆ†æ

### å®Œæ•´å¯¹æ¯”è¡¨

| ç»´åº¦ | RRT | RRT* | Informed RRT* | BIT* |
|------|-----|------|---------------|------|
| **ä»£ç è¡Œæ•°** | 291 | 289 | 350 | 635 |
| **ç±»æ•°é‡** | 1 | 1 | 1 | 2 |
| **æ•°æ®ç»“æ„** | æ ‘ | æ ‘+ä»£ä»· | æ ‘+ä»£ä»·+æ¤­åœ† | æ ‘+åŒé˜Ÿåˆ—+å›¾ |
| **æ¸è¿›æœ€ä¼˜** | âŒ | âœ… | âœ… | âœ… |
| **é‡‡æ ·ç­–ç•¥** | å…¨ç©ºé—´éšæœº | å…¨ç©ºé—´éšæœº | æ¤­åœ†å½¢ | æ¤­åœ†+æ‰¹å¤„ç† |
| **å›¾æœç´¢** | âŒ | âŒ | âŒ | âœ… |
| **ä¿¡æ¯é‡ç”¨** | âŒ | éƒ¨åˆ† | éƒ¨åˆ† | âœ… å®Œå…¨ |
| **æ”¶æ•›é€Ÿåº¦** | æ…¢ | ä¸­ | å¿« | æœ€å¿« |
| **ç†è®ºæ”¶æ•›ç‡** | - | O(1/log n) | O(1/log n) | O(1/n) |
| **å†…å­˜æ¶ˆè€—** | ä½ | ä¸­ | ä¸­ | é«˜ |
| **å®ç°éš¾åº¦** | â­ | â­â­ | â­â­â­ | â­â­â­â­ |

### ç®—æ³•æ¼”è¿›è¯¦è§£

#### RRT (1998) - åŸºç¡€

**æ ¸å¿ƒæ€æƒ³**:
- éšæœºé‡‡æ ·
- æœ€è¿‘é‚»æ‰©å±•
- ç®€å•ç¢°æ’æ£€æµ‹

**ä¼˜ç‚¹**:
- âœ… å®ç°ç®€å•
- âœ… å¿«é€Ÿæ‰¾åˆ°è·¯å¾„
- âœ… é€‚åˆé«˜ç»´ç©ºé—´

**ç¼ºç‚¹**:
- âŒ ä¸ä¿è¯æœ€ä¼˜æ€§
- âŒ è·¯å¾„è´¨é‡å·®

#### RRT* (2011) - æ¸è¿›æœ€ä¼˜

**æ”¹è¿›ç‚¹**:
1. **ä»£ä»·å‡½æ•°**: å¼•å…¥ g_scores
2. **é€‰æ‹©çˆ¶èŠ‚ç‚¹**: choose_parent() é€‰æ‹©æœ€ä¼˜çˆ¶èŠ‚ç‚¹
3. **é‡å¸ƒçº¿**: rewire() ä¼˜åŒ–ç°æœ‰è¿æ¥

**ä¼ªä»£ç **:
```
sample_random() â†’ nearest() â†’ steer()
  â†“
choose_parent() # é€‰æ‹©ä»£ä»·æœ€å°çš„çˆ¶èŠ‚ç‚¹
  â†“
rewire() # é‡å¸ƒçº¿ä¼˜åŒ–é‚»å±…
```

#### Informed RRT* (2014) - æ¤­åœ†é‡‡æ ·

**æ ¸å¿ƒåˆ›æ–°**:
- æ¤­åœ†å½¢é‡‡æ ·ç©ºé—´
- cBest é©±åŠ¨çš„é‡‡æ ·æ”¶ç¼©
- æ›´å¿«æ”¶æ•›åˆ°æœ€ä¼˜è§£

**æ¤­åœ†æ”¶ç¼©è¿‡ç¨‹**:
```
Initial:  cBest = inf   â†’  é‡‡æ ·å…¨ç©ºé—´
Found:    cBest = 10    â†’  æ¤­åœ† [===================]
Better:   cBest = 5     â†’  æ¤­åœ† [=========]
Optimal:  cBest = cMin  â†’  æ¤­åœ† [==]
```

#### Batch Informed RRT* (2014) - æ‰¹å¤„ç†å›¾æœç´¢

**æ ¸å¿ƒåˆ›æ–°**:
1. **æ‰¹å¤„ç†**: ä¸æ˜¯æ¯æ¬¡è¿­ä»£éƒ½é‡‡æ ·
2. **åŒé˜Ÿåˆ—**: vertex_queue + edge_queue
3. **å›¾æœç´¢**: åƒ A* ä¸€æ ·ç»´æŠ¤å’Œæ›´æ–°å›¾

**æ‰¹å¤„ç†ä¼˜åŠ¿**:
```
RRT*:     Sample â†’ Expand â†’ Rewire â†’ Sample â†’ ...
Informed: Sample â†’ Expand â†’ Rewire â†’ Sample â†’ ... (æ¤­åœ†å†…)
BIT*:     [Sample å¤šä¸ª] â†’ [Expand å¤šä¸ª] â†’ [Connect å¤šä¸ª]
         â†‘ æ‰¹å¤„ç†        â†‘ å›¾æœç´¢        â†‘ ä¿¡æ¯é‡ç”¨
```

### æ€§èƒ½ç‰¹å¾å¯¹æ¯”

#### åœºæ™¯ 1: ç®€å•ç¯å¢ƒï¼ˆç¨€ç–éšœç¢ï¼‰

| ç®—æ³• | æ”¶æ•›æ—¶é—´ | è·¯å¾„è´¨é‡ | é€‚ç”¨æ€§ |
|------|---------|---------|--------|
| RRT | â­â­â­â­â­ | â­â­ | âœ… æ¨è |
| RRT* | â­â­â­ | â­â­â­â­ | âœ… å¯ç”¨ |
| Informed RRT* | â­â­â­â­ | â­â­â­â­â­ | âœ… æ¨è |
| BIT* | â­â­â­ | â­â­â­â­â­ | âš ï¸ è¿‡åº¦è®¾è®¡ |

#### åœºæ™¯ 2: å¤æ‚ç¯å¢ƒï¼ˆå¯†é›†éšœç¢ï¼‰

| ç®—æ³• | æ”¶æ•›æ—¶é—´ | è·¯å¾„è´¨é‡ | é€‚ç”¨æ€§ |
|------|---------|---------|--------|
| RRT | â­â­ | â­ | âš ï¸ å‹‰å¼ºå¯ç”¨ |
| RRT* | â­â­ | â­â­â­ | âš ï¸ æ…¢ |
| Informed RRT* | â­â­â­ | â­â­â­â­ | âœ… æ¨è |
| BIT* | â­â­â­â­ | â­â­â­â­â­ | âœ… æœ€ä¼˜ |

#### åœºæ™¯ 3: é«˜ç»´ç©ºé—´ï¼ˆ>3ç»´ï¼‰

| ç®—æ³• | æ”¶æ•›æ—¶é—´ | è·¯å¾„è´¨é‡ | é€‚ç”¨æ€§ |
|------|---------|---------|--------|
| RRT | â­â­â­â­ | â­ | âœ… æ¨è |
| RRT* | â­â­ | â­â­â­ | âš ï¸ å¾ˆæ…¢ |
| Informed RRT* | â­â­â­ | â­â­â­â­ | âœ… æ¨è |
| BIT* | â­â­â­â­â­ | â­â­â­â­â­ | âœ… æœ€ä¼˜ |

### ä»£ç å¤æ‚åº¦å¯¹æ¯”

#### æ•°æ®ç»“æ„å¤æ‚åº¦

| ç®—æ³• | ä¸»è¦æ•°æ®ç»“æ„ | æ•°é‡ | ç»´æŠ¤å¤æ‚åº¦ |
|------|-------------|------|-----------|
| RRT | æ ‘ (dict) | 1 | O(1) |
| RRT* | æ ‘ + ä»£ä»· (dict) | 2 | O(1) |
| Informed RRT* | æ ‘ + ä»£ä»· + æ¤­åœ†å‚æ•° | 3 | O(1) |
| BIT* | æ ‘ + ä»£ä»· + åŒé˜Ÿåˆ— + é‡‡æ ·é›† + å›¾ | 5 | O(n) |

#### æ–¹æ³•æ•°é‡å¯¹æ¯”

| ç®—æ³• | æ ¸å¿ƒæ–¹æ³• | è¾…åŠ©æ–¹æ³• | æ€»è®¡ |
|------|---------|---------|------|
| RRT | 5 | 3 | 8 |
| RRT* | 8 | 5 | 13 |
| Informed RRT* | 10 | 6 | 16 |
| BIT* | 15 | 17 | 32 |

---

## ğŸ¨ å…³é”®ç®—æ³•å®ç°

### 1. æ¤­åœ†å½¢é‡‡æ · (informed_sample)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:397-415`

**å®Œæ•´å®ç°**:

```python
def informed_sample(self, m, cMax, cMin, xCenter, C):
    samples = dict()
    for i in range(m + 1):
        if cMax < float('inf'):
            # 1. æ„å»ºæ¤­åœ†å¯¹è§’çŸ©é˜µ
            r = [cMax / 2.0,
                 math.sqrt(cMax ** 2 - cMin ** 2) / 2.0,
                 math.sqrt(cMax ** 2 - cMin ** 2) / 2.0]
            L = np.diag(r)

            # 2. åœ¨å•ä½çƒå†…é‡‡æ ·
            xBall = self.sample_unit_ball()

            # 3. å˜æ¢åˆ°æ¤­åœ†ç©ºé—´
            rnd = np.dot(np.dot(C, L), xBall) + xCenter
            rnd = [rnd[(0, 0)], rnd[(1, 0)]]

            # 4. è®°å½•é‡‡æ ·ç‚¹
            random_id = self.tree.real_world_to_node_id(rnd)
            samples[random_id] = rnd
        else:
            # å…¨ç©ºé—´é‡‡æ ·
            rnd = self.sample_free_space()
            random_id = self.tree.real_world_to_node_id(rnd)
            samples[random_id] = rnd
    return samples
```

**æ•°å­¦æ¨å¯¼**:

1. **æ¤­åœ†æ–¹ç¨‹**:
   \[
   \frac{(x-x_c)^2}{a^2} + \frac{(y-y_c)^2}{b^2} \leq 1
   \]
   å…¶ä¸­:
   \[
   a = \frac{c_{best}}{2}, \quad b = \frac{\sqrt{c_{best}^2 - c_{min}^2}}{2}
   \]

2. **é‡‡æ ·å˜æ¢**:
   \[
   x_{sample} = C \cdot L \cdot x_{ball} + x_{center}
   \]

   - \(C\): æ—‹è½¬çŸ©é˜µï¼ˆSVD åˆ†è§£å¾—åˆ°ï¼‰
   - \(L\): å¯¹è§’ç¼©æ”¾çŸ©é˜µ
   - \(x_{ball}\): å•ä½çƒå†…çš„ç‚¹
   - \(x_{center}\): æ¤­åœ†ä¸­å¿ƒ

**å…³é”®ç‚¹**:
- âš ï¸ å½“ cMax = inf æ—¶ï¼Œå…¨ç©ºé—´é‡‡æ ·ï¼ˆæœªæ‰¾åˆ°è·¯å¾„ï¼‰
- âœ… cMax è¶Šå°ï¼Œæ¤­åœ†è¶Šçª„ï¼Œé‡‡æ ·è¶Šèšç„¦
- ğŸ’¡ cMax çš„æ›´æ–°é©±åŠ¨æœç´¢èšç„¦

### 2. å•ä½çƒé‡‡æ · (sample_unit_ball)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:419-428`

**æ•°å­¦æŠ€å·§**:

```python
@staticmethod
def sample_unit_ball():
    a = random.random()
    b = random.random()

    # ç¡®ä¿ a <= b
    if b < a:
        a, b = b, a

    # å‡åŒ€åˆ†å¸ƒåœ¨åœ†å†…
    sample = (b * math.cos(2 * math.pi * a / b),
              b * math.sin(2 * math.pi * a / b))
    return np.array([[sample[0]], [sample[1]], [0]])
```

**ä¸ºä»€ä¹ˆè¿™æ ·é‡‡æ ·ï¼Ÿ**

**é¢ç§¯å‡åŒ€åˆ†å¸ƒæ¨å¯¼**:

1. **é”™è¯¯æ–¹æ³•**: åŠå¾„å‡åŒ€åˆ†å¸ƒ
   ```python
   r = random.random()  # âŒ ä¼šå¯¼è‡´ä¸­å¿ƒèšé›†
   theta = random.random() * 2 * pi
   x = r * cos(theta)
   y = r * sin(theta)
   ```

2. **æ­£ç¡®æ–¹æ³•**: é¢ç§¯å‡åŒ€åˆ†å¸ƒ
   - é¢ç§¯å¾®å…ƒ: \(dA = r dr d\theta\)
   - ç´¯ç§¯åˆ†å¸ƒå‡½æ•°: \(F(r) = r^2\)
   - é€†å˜æ¢é‡‡æ ·: \(r = \sqrt{u}\), å…¶ä¸­ \(u \sim U[0,1]\)

3. **æœ¬ä»£ç çš„å®ç°**:
   - ä½¿ç”¨ \(b\) ä½œä¸ºåŠå¾„ï¼Œ\(a/b\) ä½œä¸ºè§’åº¦æ¯”ä¾‹
   - æ•°å­¦ä¸Šç­‰ä»·äºé¢ç§¯å‡åŒ€åˆ†å¸ƒ
   - å‚è€ƒ: ã€ŠUniform Sampling from a Sphereã€‹

**å¯è§†åŒ–**:
```
é”™è¯¯é‡‡æ ·ï¼ˆä¸­å¿ƒèšé›†ï¼‰      æ­£ç¡®é‡‡æ ·ï¼ˆé¢ç§¯å‡åŒ€ï¼‰
    â—â—â—                    â—  â—  â—
   â—â– â– â—â—                  â—  â—  â—  â—
  â—â– â– â– â—â—â—                 â—  â—  â—  â—
   â—â—â—â—â—                  â—  â—  â—  â—
    â—â—â—                     â—  â—  â—
```

### 3. ç¢°æ’æ£€æµ‹è¿æ¥ (connect)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:356-371`

**ç¦»æ•£åŒ–æ£€æµ‹**:

```python
def connect(self, start, end):
    # 1. è®¡ç®—ç¦»æ•£åŒ–æ­¥æ•°
    steps = int(self.compute_distance_cost(
        self.tree.real_world_to_node_id(start),
        self.tree.real_world_to_node_id(end)) * 10)

    # 2. ç”Ÿæˆç¦»æ•£ç‚¹
    x = np.linspace(start[0], end[0], num=steps)
    y = np.linspace(start[1], end[1], num=steps)

    # 3. é€ç‚¹æ£€æµ‹ç¢°æ’
    for i in range(len(x)):
        if self._collision_check(x[i], y[i]):
            if i == 0:
                return None  # èµ·ç‚¹å°±ç¢°æ’
            # è¿”å›ç¢°æ’å‰çš„è·¯å¾„
            return np.vstack((x[0:i], y[0:i])).transpose()

    # 4. æ— ç¢°æ’ï¼Œè¿”å›å®Œæ•´è·¯å¾„
    return np.vstack((x, y)).transpose()
```

**ä¸ºä»€ä¹ˆç”¨ 10 å€å¯†åº¦ï¼Ÿ**
- âš ï¸ å¹³è¡¡ç²¾åº¦å’Œæ•ˆç‡
- âš ï¸ é˜²æ­¢ç©¿è¶Šè–„éšœç¢ç‰©
- âš ï¸ 10 æ˜¯ç»éªŒå€¼ï¼Œå¯æ ¹æ®éšœç¢ç‰©è°ƒæ•´

**ç¢°æ’æ£€æµ‹**:

```python
def _collision_check(self, x, y):
    for (ox, oy, size) in self.obstacleList:
        dx = ox - x
        dy = oy - y
        d = dx * dx + dy * dy
        if d <= size ** 2:
            return True  # ç¢°æ’
    return False
```

### 4. è¾¹è¿æ¥æ¡ä»¶åˆ¤æ–­

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:254-271`

**ä¸‰ä¸ªæ¡ä»¶**:

```python
# ä¼°è®¡é¡¶ç‚¹ä»£ä»·ï¼ˆé€šè¿‡è¿™æ¡è¾¹ï¼‰
estimatedCostOfVertex = g_scores[bestEdge[0]] + distance(bestEdge[0], bestEdge[1]) + h(bestEdge[1], goal)

# ä¼°è®¡è¾¹ä»£ä»·ï¼ˆä»èµ·ç‚¹ï¼‰
estimatedCostOfEdge = distance(start, bestEdge[0]) + h(bestEdge[0], bestEdge[1]) + h(bestEdge[1], goal)

# å®é™…è¾¹ä»£ä»·ï¼ˆå·²éªŒè¯éƒ¨åˆ†ï¼‰
actualCostOfEdge = g_scores[bestEdge[0]] + distance(bestEdge[0], bestEdge[1])

# ä¸‰ä¸ªæ¡ä»¶
f1 = estimatedCostOfVertex < g_scores[goalId]
f2 = estimatedCostOfEdge < g_scores[goalId]
f3 = actualCostOfEdge < g_scores[goalId]

if f1 and f2 and f3:
    # è¿æ¥è¿™æ¡è¾¹
```

**æ¡ä»¶å«ä¹‰**:

| æ¡ä»¶ | å«ä¹‰ | ä½œç”¨ |
|------|------|------|
| f1 | é€šè¿‡é¡¶ç‚¹çš„è·¯å¾„å¯èƒ½æ”¹è¿›å½“å‰è§£ | å¯å‘å¼åˆ¤æ–­ |
| f2 | ä»èµ·ç‚¹åˆ°è¾¹çš„ä¼°è®¡å¯èƒ½æ”¹è¿› | å…¨å±€è§†è§’ |
| f3 | è¾¹çš„å®é™…ä»£ä»·ç¡®å®æ›´å° | ä¿è¯æ”¹è¿› |

**ä¸ºä»€ä¹ˆéœ€è¦ä¸‰ä¸ªæ¡ä»¶ï¼Ÿ**
- f1: é¡¶ç‚¹çº§åˆ«çš„å¯å‘å¼ä¼°è®¡
- f2: è¾¹çº§åˆ«çš„å¯å‘å¼ä¼°è®¡
- f3: å®é™…æµ‹é‡ï¼ˆè€ƒè™‘ç¢°æ’ï¼‰
- ä¸‰è€…åŒæ—¶æ»¡è¶³æ‰èƒ½ä¿è¯è¾¹èƒ½æ”¹è¿›è§£

### 5. å¯è§†åŒ– (draw_graph)

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:565-608`

**ç»˜å›¾å…ƒç´ **:

```python
# é‡‡æ ·ç‚¹ï¼ˆé»‘è‰²ä¸‰è§’ï¼‰
plt.plot(rnd[0], rnd[1], "^k")

# æ–°è¿æ¥çš„è¾¹ï¼ˆç»¿è‰²å®çº¿ï¼‰
plt.plot([start[0], start[1]], [end[0], end[1]], "-g")

# éšœç¢ç‰©ï¼ˆé»‘è‰²åœ†ï¼‰
plt.plot(ox, oy, "ok", ms=30 * size)

# èµ·ç‚¹/ç»ˆç‚¹ï¼ˆçº¢è‰²å‰ï¼‰
plt.plot(self.start[0], self.start[1], "xr")
plt.plot(self.goal[0], self.goal[1], "xr")

# æ¤­åœ†è¾¹ç•Œï¼ˆé’è‰²è™šçº¿ï¼‰
self.plot_ellipse(xCenter, cBest, cMin, eTheta)
```

**æ¤­åœ†ç»˜åˆ¶**:

```python
@staticmethod
def plot_ellipse(xCenter, cBest, cMin, eTheta):
    # 1. è®¡ç®—æ¤­åœ†å‚æ•°
    a = math.sqrt(cBest ** 2 - cMin ** 2) / 2.0
    b = cBest / 2.0
    angle = math.pi / 2.0 - eTheta

    # 2. å‚æ•°æ–¹ç¨‹
    t = np.arange(0, 2 * math.pi + 0.1, 0.1)
    x = [a * math.cos(it) for it in t]
    y = [b * math.sin(it) for it in t]

    # 3. æ—‹è½¬çŸ©é˜µ
    R = np.array([[math.cos(angle), math.sin(angle)],
                  [-math.sin(angle), math.cos(angle)]])

    # 4. å˜æ¢å¹¶ç»˜åˆ¶
    fx = R @ np.array([x, y])
    px = np.array(fx[0, :] + xCenter).flatten()
    py = np.array(fx[1, :] + yCenter).flatten()
    plt.plot(xCenter[0], xCenter[1], "xc")  # ä¸­å¿ƒ
    plt.plot(px, py, "--c")  # æ¤­åœ†è¾¹ç•Œ
```

---

## ğŸ§ª å®éªŒåœºæ™¯ä¸å‚æ•°

### é»˜è®¤æµ‹è¯•åœºæ™¯

**ä»£ç ä½ç½®**: `batch_informed_rrt_star.py:611-621`

```python
def main(maxIter=80):
    # èµ·ç‚¹å’Œç»ˆç‚¹
    start = [-1, 0]
    goal = [3, 8]

    # éšœç¢ç‰©åˆ—è¡¨ (x, y, radius)
    obstacleList = [
        (5, 5, 0.5),
        (9, 6, 1),
        (7, 5, 1),
        (1, 5, 1),
        (3, 6, 1),
        (7, 9, 1)
    ]

    # é‡‡æ ·ç©ºé—´
    randArea = [-2, 15]

    # æœ€å¤§è¿­ä»£
    maxIter = 80
```

**åœ°å›¾å¯è§†åŒ–**:

```
15 â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚              â–ˆ
10 â”‚              â–ˆ  (7,9,1)
   â”‚              â–ˆ
 5 â”‚  â–ˆ   â–ˆ   â–ˆ  â–ˆ
   â”‚(1,5) (5,5) (7,5) (9,6)
 0 â”‚S              â–ˆG
   â”‚              â–ˆ(3,6)
-2 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´
  -2   2   6   10  15

S = Start (-1, 0)
G = Goal (3, 8)
â–ˆ = Obstacles
```

### å…³é”®å‚æ•°è¯´æ˜

| å‚æ•° | ä½ç½® | é»˜è®¤å€¼ | ä½œç”¨ | è°ƒæ•´å½±å“ |
|------|------|--------|------|---------|
| `eta` | 157 è¡Œ | 2.0 | æœç´¢åŠå¾„ç³»æ•° | å¢å¤§â†’æœç´¢èŒƒå›´å¹¿ï¼Œå‡å°â†’æ›´ç²¾ç»† |
| `resolution` | 165 è¡Œ | 0.01 | ç½‘æ ¼åˆ†è¾¨ç‡ | å‡å°â†’ç²¾åº¦â†‘ï¼Œå†…å­˜â†‘ |
| `maxIter` | 624 è¡Œ | 80 | æœ€å¤§è¿­ä»£æ¬¡æ•° | å¢å¤§â†’æˆåŠŸç‡â†‘ï¼Œæ—¶é—´â†‘ |
| `r` | 211 è¡Œ | 2.0 | é‚»åŸŸåŠå¾„ | å¢å¤§â†’è¿æ¥æ¦‚ç‡â†‘ï¼Œè®¡ç®—â†‘ |

**å‚æ•°æ•æ„Ÿæ€§åˆ†æ**:

#### å®éªŒ 1: eta å‚æ•°å½±å“

```python
# æµ‹è¯•ä¸åŒ eta å€¼
for eta in [0.5, 1.0, 2.0, 5.0]:
    bitStar = BITStar(eta=eta, ...)
    # è§‚å¯Ÿæ”¶æ•›é€Ÿåº¦å’Œè·¯å¾„è´¨é‡
```

**é¢„æœŸç»“æœ**:
- eta å° (0.5): æ”¶æ•›æ…¢ï¼Œè·¯å¾„ç²¾ç»†
- eta ä¸­ (2.0): å¹³è¡¡
- eta å¤§ (5.0): æ”¶æ•›å¿«ï¼Œä½†å¯èƒ½ç²—ç³™

#### å®éªŒ 2: maxIter å½±å“

```python
for maxIter in [20, 40, 80, 160]:
    bitStar = BITStar(maxIter=maxIter, ...)
    # è§‚å¯ŸæˆåŠŸç‡å’Œè·¯å¾„è´¨é‡
```

### å¯è§†åŒ–å…ƒç´ è¯´æ˜

| ç¬¦å· | å«ä¹‰ | ä»£ç ä½ç½® |
|------|------|---------|
| `^k` | é‡‡æ ·ç‚¹ï¼ˆé»‘è‰²ä¸‰è§’ï¼‰ | 574 è¡Œ |
| `--c` | æ¤­åœ†è¾¹ç•Œï¼ˆé’è‰²è™šçº¿ï¼‰ | 608 è¡Œ |
| `-g` | æ–°è¿æ¥çš„è¾¹ï¼ˆç»¿è‰²å®çº¿ï¼‰ | 579 è¡Œ |
| `ok` | éšœç¢ç‰©ï¼ˆé»‘è‰²åœ†ï¼‰ | 582 è¡Œ |
| `xr` | èµ·ç‚¹/ç»ˆç‚¹ï¼ˆçº¢è‰²å‰ï¼‰ | 584-585 è¡Œ |

---

## ğŸ“ˆ æ€§èƒ½åˆ†æ

### æ—¶é—´å¤æ‚åº¦

**å„é˜¶æ®µå¤æ‚åº¦**:

1. **åˆå§‹åŒ–** (setup_planning):
   - SVD åˆ†è§£: O(nÂ³), n=3 â†’ O(1)
   - åˆå§‹é‡‡æ ·: O(m), m=200 â†’ O(m)

2. **æ‰¹å¤„ç†é‡‡æ ·** (setup_sample):
   - é‡‡æ ·: O(m)
   - é‚»åŸŸæœç´¢: O(n Ã— k), n=é¡¶ç‚¹æ•°, k=é‚»å±…æ•°

3. **é¡¶ç‚¹æ‰©å±•** (expand_vertex):
   - é‚»å±…æŸ¥æ‰¾: O(m Ã— n)
   - è¾¹é˜Ÿåˆ—æ›´æ–°: O(k)

4. **å›¾æ›´æ–°** (update_graph):
   - A* é£æ ¼æœç´¢: O(V log V + E)

**æ€»å¤æ‚åº¦**:
```
å•æ¬¡è¿­ä»£: O(m + nÃ—k + V log V + E)
å¤šæ¬¡è¿­ä»£: O(iter Ã— (m + nÃ—k + V log V + E))
```

### ç©ºé—´å¤æ‚åº¦

**æ•°æ®ç»“æ„å ç”¨**:

```python
tree.vertices:  O(V)           # æ ‘é¡¶ç‚¹
tree.edges:     O(E)           # æ ‘è¾¹
samples:        O(m)           # é‡‡æ ·é›†åˆ
vertex_queue:   O(V)           # é¡¶ç‚¹é˜Ÿåˆ—
edge_queue:     O(E)           # è¾¹é˜Ÿåˆ—
g_scores:       O(V)           # ä»£ä»·å­—å…¸
f_scores:       O(V)           # ä¼°è®¡ä»£ä»·
nodes:          O(V)           # çˆ¶å­å…³ç³»

æ€»è®¡: O(V + E + m)
```

**å¯¹æ¯”**:

| ç®—æ³• | ç©ºé—´å¤æ‚åº¦ | ä¸»è¦æ¶ˆè€— |
|------|-----------|---------|
| RRT | O(V) | æ ‘ç»“æ„ |
| RRT* | O(V) | æ ‘ + ä»£ä»· |
| Informed RRT* | O(V + m) | æ ‘ + é‡‡æ · |
| BIT* | O(V + E + m) | æ ‘ + é˜Ÿåˆ— + é‡‡æ · |

### æ”¶æ•›æ€§åˆ†æ

**ç†è®ºæ”¶æ•›ç‡**:

\[
\begin{aligned}
\text{RRT*}: &\quad O(1/\log n) \\
\text{Informed RRT*}: &\quad O(1/\log n) \text{ (ä½†æœ‰æ›´å°çš„å¸¸æ•°)} \\
\text{BIT*}: &\quad O(1/n)
\end{aligned}
\]

**å®é™…æ€§èƒ½å¯¹æ¯”**:

| è¿­ä»£æ¬¡æ•° | RRT | RRT* | Informed RRT* | BIT* |
|---------|-----|------|---------------|------|
| 10 | å·® | ä¸­ | è‰¯å¥½ | ä¼˜ç§€ |
| 50 | å·® | è‰¯å¥½ | ä¼˜ç§€ | æœ€ä¼˜ |
| 100 | ä¸­ | è‰¯å¥½ | æœ€ä¼˜ | æœ€ä¼˜ |
| 500 | è‰¯å¥½ | ä¼˜ç§€ | æœ€ä¼˜ | æœ€ä¼˜ |

### æ€§èƒ½ç“¶é¢ˆ

**ä¸»è¦ç“¶é¢ˆ**:

1. **SVD åˆ†è§£** (ç¬¬ 196 è¡Œ):
   - å¤æ‚åº¦: O(nÂ³)
   - å½±å“: æ¯æ¬¡é‡‡æ ·æ›´æ–°æ—¶è°ƒç”¨
   - ä¼˜åŒ–: é¢„è®¡ç®—æ—‹è½¬çŸ©é˜µ

2. **é‚»åŸŸæœç´¢** (ç¬¬ 484 è¡Œ):
   - å¤æ‚åº¦: O(m Ã— n)
   - å½±å“: é¡¶ç‚¹æ‰©å±•æ—¶
   - ä¼˜åŒ–: ä½¿ç”¨ KD-tree

3. **å›¾æ›´æ–°** (ç¬¬ 521 è¡Œ):
   - å¤æ‚åº¦: O(V log V + E)
   - å½±å“: æ¯æ¬¡æ·»åŠ è¾¹å
   - ä¼˜åŒ–: å¢é‡å¼æ›´æ–°

---

## ğŸ’¡ å­¦ä¹ å¿ƒå¾—

### æ ¸å¿ƒåˆ›æ–°ç‚¹æ€»ç»“

1. **æ‰¹å¤„ç†æ€æƒ³**:
   - ğŸ’¡ ä¸æ˜¯æ¯æ¬¡è¿­ä»£éƒ½é‡‡æ ·
   - ğŸ’¡ æ‰¹é‡é‡‡æ ·åæ‰¹é‡å¤„ç†
   - ğŸ’¡ å‡å°‘é‡å¤è®¡ç®—

2. **åŒé˜Ÿåˆ—ç³»ç»Ÿ**:
   - ğŸ’¡ vertex_queue: æ§åˆ¶æ‰©å±•æ–¹å‘
   - ğŸ’¡ edge_queue: ç¼“å­˜å€™é€‰è¿æ¥
   - ğŸ’¡ åè°ƒæœºåˆ¶: vertex_value â‰¤ edge_value

3. **å›¾æœç´¢é›†æˆ**:
   - ğŸ’¡ åƒ A* ä¸€æ ·ç»´æŠ¤ä»£ä»·
   - ğŸ’¡ å¢é‡å¼æ›´æ–°å›¾
   - ğŸ’¡ ç»“åˆé‡‡æ ·å’Œæœç´¢ä¼˜åŠ¿

4. **ä¿¡æ¯é‡ç”¨**:
   - ğŸ’¡ æ ‘ç»“æ„åœ¨è¿­ä»£é—´ä¿æŒ
   - ğŸ’¡ ä»£ä»·å‡½æ•°æŒç»­æ›´æ–°
   - ğŸ’¡ é¿å…é‡å¤è®¡ç®—

### å®ç°éš¾ç‚¹

**éš¾ç‚¹ 1: åæ ‡è½¬æ¢ç³»ç»Ÿ**

**é—®é¢˜**: ä¸ºä»€ä¹ˆéœ€è¦ä¸‰å±‚è½¬æ¢ï¼Ÿ

**è§£ç­”**:
```
Real World (è¿ç»­) â†’ Grid Space (ç¦»æ•£) â†’ Node ID (æ•´æ•°)
     â†“                    â†“                    â†“
  äººç±»ç†è§£          ç©ºé—´ç´¢å¼•åŠ é€Ÿ          å­—å…¸é”®å€¼
```

- Real World: è¿ç»­åæ ‡ (1.23, 4.56)
- Grid Space: ç¦»æ•£åŒ– (123, 456)
- Node ID: å”¯ä¸€æ•´æ•° (123456)

**éš¾ç‚¹ 2: æ¤­åœ†é‡‡æ ·çš„ SVD åˆ†è§£**

**é—®é¢˜**: ä¸ºä»€ä¹ˆç”¨ SVDï¼Ÿ

**è§£ç­”**:
- æ„é€ ä»èµ·ç‚¹åˆ°ç»ˆç‚¹çš„æ—‹è½¬çŸ©é˜µ
- SVD ä¿è¯æ­£äº¤æ€§
- å°†å•ä½çƒå˜æ¢ä¸ºæ¤­åœ†

**éš¾ç‚¹ 3: åŒé˜Ÿåˆ—åè°ƒ**

**é—®é¢˜**: ä½•æ—¶æ‰©å±•é¡¶ç‚¹ vs è¿æ¥è¾¹ï¼Ÿ

**è§£ç­”**:
- vertex_value â‰¤ edge_value: æ‰©å±•é¡¶ç‚¹
- vertex_value > edge_value: è¿æ¥è¾¹
- ä¿è¯æœç´¢æ•ˆç‡å’Œè´¨é‡å¹³è¡¡

**éš¾ç‚¹ 4: å›¾æ›´æ–°ä¸ A* çš„å…³ç³»**

**é—®é¢˜**: BIT* çš„ update_graph å’Œ A* æœ‰ä½•ä¸åŒï¼Ÿ

**è§£ç­”**:
- A*: ä»ç©ºå›¾å¼€å§‹æœç´¢
- BIT*: åœ¨ç°æœ‰æ ‘ä¸Šæ›´æ–°
- éƒ½ç”¨ f = g + h

### é€‚ç”¨åœºæ™¯

**âœ… æ¨èä½¿ç”¨**:
- é«˜ç»´ç©ºé—´è§„åˆ’ (ç»´åº¦ > 3)
- å¤æ‚éšœç¢ç¯å¢ƒ
- éœ€è¦å¿«é€Ÿæ”¶æ•›åˆ°æœ€ä¼˜è§£
- ç¦»çº¿è§„åˆ’ï¼ˆè®¡ç®—èµ„æºå……è¶³ï¼‰
- éœ€è¦å¤šæ¬¡é‡è§„åˆ’

**âŒ ä¸æ¨èä½¿ç”¨**:
- å†…å­˜å—é™ç¯å¢ƒ
- æç®€å•ç¯å¢ƒï¼ˆRRT è¶³å¤Ÿï¼‰
- å®æ—¶æ€§è¦æ±‚æé«˜ï¼ˆRRT æ›´å¿«ï¼‰
- 2D ç®€å•ç¯å¢ƒï¼ˆA* æ›´å¥½ï¼‰

### ä¸å…¶ä»–ç®—æ³•çš„äº’è¡¥æ€§

**ç®—æ³•é€‰æ‹©å†³ç­–æ ‘**:

```
ç¯å¢ƒç®€å•ï¼Ÿ
  â”œâ”€ Yes â†’ ä½¿ç”¨ A* æˆ– Dijkstra
  â””â”€ No â†’ é«˜ç»´ç©ºé—´ï¼Ÿ
      â”œâ”€ Yes â†’ éœ€è¦æœ€ä¼˜æ€§ï¼Ÿ
      â”‚   â”œâ”€ Yes â†’ BIT* æˆ– Informed RRT*
      â”‚   â””â”€ No â†’ RRT
      â””â”€ No (2D) â†’ éœ€è¦æœ€ä¼˜æ€§ï¼Ÿ
          â”œâ”€ Yes â†’ RRT* æˆ– Informed RRT*
          â””â”€ No â†’ RRT
```

---

## ğŸ”¬ è¿›é˜¶å®éªŒå»ºè®®

### å®éªŒ 1: ç®—æ³•å…¨é¢å¯¹æ¯”

**å®éªŒä»£ç **: `experiments/batch_rrt_comparison.py`

```python
"""
BIT* vs RRT* vs Informed RRT* æ€§èƒ½å¯¹æ¯”
"""
import sys
import time
sys.path.append('/home/zhufeng/code/PythonRobotics/PythonRobotics')

# ç»Ÿä¸€æµ‹è¯•åœºæ™¯
start = [-1, 0]
goal = [3, 8]
obstacles = [(5, 5, 0.5), (9, 6, 1), (7, 5, 1), (1, 5, 1), (3, 6, 1), (7, 9, 1)]

# æµ‹è¯• RRT*
# æµ‹è¯• Informed RRT*
# æµ‹è¯• BIT*

# å¯¹æ¯”æŒ‡æ ‡:
# - æ”¶æ•›æ—¶é—´
# - è·¯å¾„é•¿åº¦
# - è¿­ä»£æ¬¡æ•°
# - æˆåŠŸç‡
```

### å®éªŒ 2: å‚æ•°æ•æ„Ÿæ€§åˆ†æ

```python
# æµ‹è¯•ä¸åŒ eta å€¼
etas = [0.5, 1.0, 2.0, 5.0]

# æµ‹è¯•ä¸åŒ maxIter
iters = [20, 40, 80, 160]

# æµ‹è¯•ä¸åŒåˆ†è¾¨ç‡
resolutions = [0.005, 0.01, 0.02, 0.05]

# ç»˜åˆ¶æ€§èƒ½æ›²çº¿
```

### å®éªŒ 3: éšœç¢å¯†åº¦å½±å“

```python
# ç¨€ç–éšœç¢ (5ä¸ª)
obstacles_sparse = [(5, 5, 0.5), (9, 6, 1), ...]

# ä¸­ç­‰éšœç¢ (10ä¸ª)
obstacles_medium = [...]

# å¯†é›†éšœç¢ (20ä¸ª)
obstacles_dense = [...]

# å¯¹æ¯”æ€§èƒ½å·®å¼‚
```

### å®éªŒ 4: èµ·ç‚¹ç»ˆç‚¹è·ç¦»å½±å“

```python
# çŸ­è·ç¦»
cMin < 5: start=[0, 0], goal=[3, 4]

# ä¸­è·ç¦»
5 < cMin < 10: start=[0, 0], goal=[8, 10]

# é•¿è·ç¦»
cMin > 10: start=[0, 0], goal=[15, 20]
```

---

## ğŸ“ æ€»ç»“

### å…³é”®è¦ç‚¹

1. **ç®—æ³•æ¼”è¿›**: RRT â†’ RRT* â†’ Informed RRT* â†’ BIT*
2. **æ ¸å¿ƒåˆ›æ–°**: æ‰¹å¤„ç† + åŒé˜Ÿåˆ— + å›¾æœç´¢
3. **æ•°å­¦åŸºç¡€**: æ¤­åœ†é‡‡æ · + SVD åˆ†è§£ + å¯å‘å¼å‡½æ•°
4. **å®ç°å¤æ‚åº¦**: â­â­â­â­ (æœ€éš¾)
5. **é€‚ç”¨åœºæ™¯**: é«˜ç»´ç©ºé—´ + å¤æ‚ç¯å¢ƒ + éœ€è¦æœ€ä¼˜è§£

### å­¦ä¹ å»ºè®®

1. **å…ˆç†è§£ RRT å’Œ RRT***: åŸºç¡€å¾ˆé‡è¦
2. **æŒæ¡æ¤­åœ†é‡‡æ ·æ•°å­¦**: æ ¸å¿ƒåˆ›æ–°ç‚¹
3. **ç†è§£åŒé˜Ÿåˆ—æœºåˆ¶**: åè°ƒé€»è¾‘
4. **å®éªŒéªŒè¯**: å¯¹æ¯”ä¸åŒç®—æ³•

### æ‰©å±•é˜…è¯»

- [BIT* è®ºæ–‡](https://arxiv.org/abs/1405.5848)
- [Informed RRT* è®ºæ–‡](https://arxiv.org/pdf/1404.2334)
- [RRT* è®ºæ–‡](https://www.ri.cmu.edu/pub_files/pub3/1/karaman_schechter_2011_3/1/karaman_schechter_2011_3.pdf)

---

**æœ€åæ›´æ–°**: 2026-01-13
**å­¦ä¹ çŠ¶æ€**: âœ… å·²å®Œæˆåˆæ­¥ç†è§£
**ä¸‹æ¬¡å¤ä¹ **: 2026-01-20
**ç›¸å…³æ ‡ç­¾**: #è·¯å¾„è§„åˆ’ #é‡‡æ ·ç®—æ³• #RRTç³»åˆ— #BIT* #é«˜çº§ç®—æ³•
