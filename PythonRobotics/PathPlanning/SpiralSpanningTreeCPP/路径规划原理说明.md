# Spiral-STC 路径规划原理详解

## 一、核心思想

Spiral-STC算法采用**两级地图结构**：
1. **原始地图**：高分辨率地图，每个单元格代表一个可访问位置
2. **合并地图**：将2×2的原始单元格合并为一个**超级单元（supercell）**

算法先在**超级单元级别**生成覆盖路径（route），然后将其**细化**为原始地图级别的详细路径（path）。

---

## 二、地图合并原理

### 2.1 超级单元结构

每个超级单元由2×2的原始单元格组成：

```
原始地图坐标：
┌─────────┬─────────┐
│ (2i,2j) │(2i,2j+1)│  ← 超级单元(i,j)的4个子单元
├─────────┼─────────┤
│(2i+1,2j)│(2i+1,2j+1)│
└─────────┴─────────┘

超级单元(i,j)包含：
- NW(西北): (2i, 2j)
- NE(东北): (2i, 2j+1)
- SW(西南): (2i+1, 2j)
- SE(东南): (2i+1, 2j+1)
```

### 2.2 有效性判断

一个超级单元是**有效的**（可访问）当且仅当：
- 它的4个子单元**全部**是自由空间（白色，值为1）
- 如果任何一个子单元是障碍物（黑色，值为0），整个超级单元无效

**代码实现**：
```python
def is_valid_node(i, j):
    return bool(
        self.occ_map[2*i][2*j]      # NW
        and self.occ_map[2*i+1][2*j]      # SW
        and self.occ_map[2*i][2*j+1]      # NE
        and self.occ_map[2*i+1][2*j+1])   # SE
```

---

## 三、路径规划的两个阶段

### 阶段1：生成超级单元路径（route）

在合并后的地图上，使用**生成树覆盖算法**生成访问路径：

```python
route = [(0,0), (1,0), (1,1), (0,1), ...]  # 超级单元坐标序列
```

**特点**：
- 路径在**超级单元级别**
- 每个超级单元至少被访问一次
- 路径形成一棵生成树（spanning tree）

### 阶段2：路径细化（route → path）

将超级单元路径转换为原始地图级别的详细路径：

```python
path = [[起点子单元, 终点子单元], ...]  # 子单元坐标序列
```

---

## 四、路径细化原理（核心部分）

### 4.1 三种情况处理

根据相邻route节点之间的**曼哈顿距离**，分为三种情况：

#### 情况1：距离为0（dp = 0）- 往返路径

**场景**：在同一超级单元内往返（回溯时可能出现）

**示例**：
```
route = [..., (i,j), (i,j), ...]
         ↑     ↑
      上一个  当前（相同）
```

**处理**：在同一超级单元内选择两个子单元形成往返路径

**代码**：
```python
if dp == 0:
    # 根据上一个节点的方向，选择往返路径
    path.append(self.get_round_trip_path(route[idx-1], route[idx]))
```

**示例**：如果从东边来，往返路径为：
- 起点：SE（东南）
- 终点：NE（东北）

**详细解释**：

1. **什么是往返路径？**
   - 在同一超级单元内，从进入点移动到另一个子单元
   - 目的是覆盖该超级单元的所有子单元

2. **为什么需要知道"从哪个方向来"？**
   - 确定进入点（从哪个边界进入）
   - 根据进入方向选择往返路径

3. **从东边来的含义**：
   ```
   route = [..., (i,j+1), (i,j), (i,j), ...]
            ↑       ↑       ↑
         上上个   上一个   当前（相同）
   
   上一个节点(i,j+1)在当前节点(i,j)的东边
   所以"从东边来"
   ```

4. **往返路径的选择逻辑**：
   ```
   超级单元(i,j)结构：
   ┌─────────┬─────────┐
   │   NW    │   NE    │  ← 上排
   ├─────────┼─────────┤
   │   SW    │   SE    │  ← 下排
   └─────────┴─────────┘
   
   从东边来 → 从右侧进入 → 进入点是SE（东南，右下角）
   往返路径：SE → NE（从右下到右上）
   
   为什么这样选择？
   - 从SE（右下）进入
   - 移动到NE（右上）
   - 覆盖了右侧的两个子单元（SE和NE）
   - **顺时针运动**
   ```

5. **其他方向的往返路径**：
   - **从南边来**：SW → SE（从下排左侧到右侧）
   - **从西边来**：NW → SW（从左侧上到下）
   - **从北边来**：NE → NW（从上排右侧到左侧）

**完整图示**（从东边来）：
```
上一个节点在右侧 → 从东边来
         ↓
    ┌─────────┬─────────┐
    │   NW    │   NE ←──┼── 终点（右上）
    ├─────────┼─────────┤
    │   SW    │   SE ───┼── 起点（右下，进入点）
    └─────────┴─────────┘
             ↑
         从东边来

路径：SE → NE（在超级单元内往返）
```

**实际场景示例**：

假设route路径如下：
```python
route = [(0,1), (0,0), (0,0), (0,1), ...]
         ↑      ↑      ↑
       上上个  上一个  当前（相同）
```

**执行过程**：

1. **处理 (0,1) → (0,0)**：
   - 距离=1，向西移动
   - 路径：NW(0,2) → NE(0,1)  （从左侧进入(0,0)）

2. **处理 (0,0) → (0,0)**：
   - 距离=0，往返路径
   - 上一个节点是(0,1)，在(0,0)的**东边**
   - 所以"从东边来"
   - 往返路径：SE → NE
     - 起点：SE(1,1) - 右下角（从东边进入的点）
     - 终点：NE(0,1) - 右上角

**可视化**：
```
原始地图坐标：
┌─────┬─────┐
│ 0,0 │ 0,1 │  ← NE(0,1) ← 终点
├─────┼─────┤
│ 1,0 │ 1,1 │  ← SE(1,1) ← 起点（从东边进入）
└─────┴─────┘
     ↑
  超级单元(0,0)

路径：(1,1) → (0,1)
说明：在超级单元(0,0)内，从右下角移动到右上角
```

**为什么是SE → NE？**

1. **从东边来**：上一个节点在右侧，所以从右侧边界进入
2. **进入点**：SE（右下角）是右侧边界的下部分
3. **往返目标**：NE（右上角）是右侧边界的上部分
4. **覆盖效果**：覆盖了右侧的两个子单元（SE和NE）

#### 情况2：距离为1（dp = 1）- 相邻节点

**场景**：两个超级单元相邻（上下左右）

**示例**：
```
route = [..., (i,j), (i+1,j), ...]
         ↑     ↑
      当前   下一个（相邻）
```

**处理**：根据移动方向，选择适当的子单元作为起点和终点

**代码**：
```python
elif dp == 1:
    path.append(self.move(route[idx], route[idx+1]))
```

**移动规则**（`move()`函数）：

| 移动方向 | 起点子单元 | 终点子单元 | 原理 |
|---------|-----------|-----------|------|
| **向东(E)** | SE（东南） | SW（西南） | 从右侧进入，从右侧离开 |
| **向西(W)** | NW（西北） | NE（东北） | 从左侧进入，从左侧离开 |
| **向南(S)** | SW（西南） | NW（西北） | 从下侧进入，从下侧离开 |
| **向北(N)** | NE（东北） | SE（东南） | 从上侧进入，从上侧离开 |

**为什么这样选择？**

确保路径**连续且覆盖完整**：
- 从当前超级单元的**边界子单元**出发
- 到达下一个超级单元的**对应边界子单元**
- 保证路径在原始地图上连续，且覆盖两个超级单元的所有子单元

**图示**（向东移动）：
```
当前超级单元(i,j)        下一个超级单元(i,j+1)
┌─────────┬─────────┐  ┌─────────┬─────────┐
│   NW    │   NE    │  │   NW    │   NE    │
├─────────┼─────────┤  ├─────────┼─────────┤
│   SW    │   SE ───┼──┼──> SW    │   SE    │
└─────────┴─────────┘  └─────────┴─────────┘
         ↑                    ↑
      起点(SE)              终点(SW)
```

#### 情况3：距离为2（dp = 2）- 非相邻节点

**场景**：两个超级单元**不相邻**（对角线或跳过中间节点）

**示例**：
```
route = [..., (i,j), (i+2,j), ...]
         ↑     ↑
      当前   下一个（距离2）
```

**处理**：需要找到**中间节点**，分两段移动

**代码**：
```python
elif dp == 2:
    # 通过生成树边查找中间节点
    mid_node = self.get_intermediate_node(route[idx], route[idx+1])
    path.append(self.move(route[idx], mid_node))      # 第一段
    path.append(self.move(mid_node, route[idx+1]))   # 第二段
```

**中间节点查找原理**（`get_intermediate_node()`）：

1. 查找起点p的所有邻居（通过生成树边）
2. 查找终点q的所有邻居（通过生成树边）
3. 找到**共同邻居**，即为中间节点

**为什么这样可行？**

因为route是在生成树上生成的，如果两个节点距离为2，它们必然有一个**共同邻居**（通过生成树边连接）。

**示例**：
```
生成树结构：
    (i,j) ── (i+1,j) ── (i+2,j)
      ↑         ↑
    起点      中间节点    终点
```

---

## 五、子单元坐标转换

### 5.1 坐标转换公式

从超级单元坐标 `(i, j)` 转换为原始地图坐标：

```python
def get_sub_node(node, direction):
    if direction == 'SE':  # 东南
        return [2*node[0]+1, 2*node[1]+1]
    elif direction == 'SW':  # 西南
        return [2*node[0]+1, 2*node[1]]
    elif direction == 'NE':  # 东北
        return [2*node[0], 2*node[1]+1]
    elif direction == 'NW':  # 西北
        return [2*node[0], 2*node[1]]
```

**推导过程**：
- 超级单元 `(i, j)` 在原始地图中的起始位置是 `(2i, 2j)`
- SE子单元：行+1，列+1 → `(2i+1, 2j+1)`
- SW子单元：行+1，列不变 → `(2i+1, 2j)`
- NE子单元：行不变，列+1 → `(2i, 2j+1)`
- NW子单元：行不变，列不变 → `(2i, 2j)`

---

## 六、完整路径规划流程

### 6.1 算法流程

```
1. 地图合并
   └─> 原始地图 (2m × 2n) → 合并地图 (m × n)

2. 生成树覆盖
   └─> 在合并地图上生成route = [(i₁,j₁), (i₂,j₂), ...]

3. 路径细化
   ├─> 遍历route中相邻节点对
   ├─> 计算曼哈顿距离 dp
   ├─> 根据dp值选择处理方式：
   │   ├─> dp=0: 往返路径
   │   ├─> dp=1: 直接移动（选择边界子单元）
   │   └─> dp=2: 分段移动（查找中间节点）
   └─> 生成path = [[子单元1, 子单元2], ...]

4. 路径输出
   └─> path是原始地图级别的详细移动路径
```

### 6.2 关键设计思想

1. **两级抽象**：
   - 超级单元级别：简化搜索空间，提高效率
   - 子单元级别：保证完整覆盖，精确路径

2. **边界子单元选择**：
   - 确保路径连续（从边界进入，从边界离开）
   - 保证覆盖完整（经过所有子单元）

3. **生成树保证**：
   - route在生成树上，保证连通性
   - 中间节点查找依赖生成树结构

---

## 七、示例说明

### 示例1：相邻节点移动（dp=1）

**输入**：
```python
route = [(0,0), (0,1)]  # 从(0,0)向东移动到(0,1)
```

**处理过程**：
1. 计算距离：`dp = |0-0| + |0-1| = 1` → 相邻节点
2. 确定方向：`get_vector_direction((0,0), (0,1)) = 'E'` → 向东
3. 选择子单元：
   - 起点：`get_sub_node((0,0), 'SE') = [1, 1]`
   - 终点：`get_sub_node((0,1), 'SW') = [1, 2]`
4. 输出路径：`path = [[1,1], [1,2]]`

**可视化**：
```
超级单元(0,0)        超级单元(0,1)
┌─────┬─────┐       ┌─────┬─────┐
│ 0,0 │ 0,1 │       │ 0,2 │ 0,3 │
├─────┼─────┤       ├─────┼─────┤
│ 1,0 │ 1,1 ───────>│ 1,2 │ 1,3 │
└─────┴─────┘       └─────┴─────┘
   ↑                   ↑
起点(SE)             终点(SW)
```

### 示例2：非相邻节点移动（dp=2）

**输入**：
```python
route = [(0,0), (0,2)]  # 从(0,0)跳过(0,1)到(0,2)
```

**处理过程**：
1. 计算距离：`dp = |0-0| + |0-2| = 2` → 非相邻节点
2. 查找中间节点：
   - p的邻居：`{(0,1), (1,0)}`（通过生成树边）
   - q的邻居：`{(0,1), (1,2)}`（通过生成树边）
   - 共同邻居：`(0,1)` → 中间节点
3. 分段移动：
   - 第一段：`(0,0) → (0,1)` → `[[1,1], [1,2]]`
   - 第二段：`(0,1) → (0,2)` → `[[1,2], [1,4]]`
4. 输出路径：`path = [[[1,1], [1,2]], [[1,2], [1,4]]]`

---

## 八、总结

路径规划的核心是**将抽象的超级单元路径细化为具体的子单元路径**，关键点：

1. **地图合并**：2×2子单元 → 1个超级单元，简化搜索
2. **路径生成**：在超级单元级别生成覆盖路径（route）
3. **路径细化**：根据节点距离，选择适当的子单元形成详细路径（path）
4. **边界选择**：确保路径连续和完整覆盖
5. **中间节点**：通过生成树结构查找，处理非相邻节点

这种设计既保证了**算法效率**（在较小的搜索空间工作），又保证了**覆盖完整性**（细化到原始地图级别）。

